{% extends "base.html" %}
{% load url from future %}

{% block body %}
<div>
  <h4>PubMed ID: {{ article.pubmed_id }}</h4>

  <div class="pull-right">
    <form action="{% url 'view_article' article.pubmed_id %}" method="post">
      {% csrf_token %}
      <input type='hidden' name='refresh' value='1' />

      <button class="btn btn-small btn-success" type="submit">
          <i class="icon-refresh icon-white"></i>
      </button>
    </form>
  </div>
</div>

<h5>{{ article.title }}</h5>

<hr>

<div id="graph">
    <!-- D3 graph goes here -->
</div>

<hr>

<ul>
{% for ref_art in article.referenced_articles.all %}
  <li><a href="{% url 'view_article' ref_art.pubmed_id %}">{{ ref_art.pubmed_id }}: {{ ref_art.title }}</a></li>
{% endfor %}
</ul>

<script src="{{ STATIC_URL }}js/d3.v3/d3.v3.min.js"></script>

<script>

    var width = 700;
    var height = 700;

    var color = d3.scale.category10();

    var force = d3.layout.force()
        .linkDistance(5)
        .linkStrength(1.0)
        .gravity(1.8)
        .friction(0.1)
        .charge(-500)
        .size([width, height]);

    var svg = d3.select("#graph").append("svg:svg")
            .attr("width", width)
            .attr("height", height);

{#    svg.append("svg:marker")#}
{#            .attr("id", "triangle")#}
{#            .attr("viewBox", "0 -5 10 10")#}
{#            .attr("refX", 25)#}
{#            .attr("refY", 0)#}
{#            .attr("markerWidth", 3)#}
{#            .attr("markerHeight", 3)#}
{#            .attr("orient", "auto")#}
{#          .append("path")#}
{#            .attr("d", "M0,-5 L10,0 L0,5");#}


{#    d3.json("{{ STATIC_URL }}miserables.json", function(error, graph) {#}
    d3.json("{% url 'article_relations' article.pubmed_id %}", function(error, graph) {
        var nodes = graph.nodes.slice();
        var links = [];
        var bilinks = [];

        // d3 force uses indices of the nodes for the links, so we need a hash lookup table
        var hash_lookup = {};
        nodes.forEach(function (d, i) {
            hash_lookup[d.pubmed_id] = i;
        });

        // And now to replace our links source and target values with the index
        graph.links.forEach(function (d, i) {
            d.source = hash_lookup[d.source];
            d.target = hash_lookup[d.target];
        });

        graph.links.forEach(function(link) {
            var s = nodes[link.source],
                    t = nodes[link.target],
                    i = {}; // intermediate node
            nodes.push(i);
            links.push({source: s, target: i}, {source: i, target: t});
            bilinks.push([s, i, t]);
        });

        // Initialize the positions deterministically, for better results.
        nodes.forEach(function(d, i) {
            if (d.group == 0) {
                d.fixed = true;
                d.x = width/2;
                d.y = 15;
            } else {
                d.x = width/2;
                d.y = height / 2 * i;
            }
        });

        force
                .nodes(nodes)
                .links(links)
                .start();

        var link = svg.selectAll(".link")
                .data(bilinks)
                .enter().append("path")
                .attr("class", "link")
                .attr("stroke-width", 0.5);
                //.attr("marker-end", "url(#triangle)");

        var node = svg.selectAll(".node")
                .data(graph.nodes)
                .enter().append("circle")
                .attr("class", "node")
                .attr("r", function(d) {
                    if (d.group == 0) {
                        return 13;
                    } else if (d.group == 1) {
                        return 5;
                    } else {
                        return 5;
                    }
                })
                .style("stroke", "#333")
                .style("fill", function(d) { return color(d.group); })
                .call(force.drag);

        node.append("title")
                .text(function(d) { return d.title; });

        force.on("tick", function(e) {
            link
                    .attr("d", function(d) {
                        return "M" + d[2].x + "," + d[2].y
                                + "S" + d[1].x + "," + d[1].y
                                + " " + d[0].x + "," + d[0].y;
                        });
            node.attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
        });
    });

</script>


{% endblock %}